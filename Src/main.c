/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

//#if !defined(__SOFT_FP__) && defined(__ARM_FP)
//  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
//#endif

#include "main.h"
#include "DS3231.h"
uint16_t times = 0;
void SysTick_Handler(void)
{
	if(times >= 1000)
	{
		GPIO_Toggle(LED6_Port, LED6_Pin);
		times = 0;
	}
	else
	{
		times++;
	}
}

void EXTI0_IRQHandler(void)
{
	if(EXTI -> PR & (1 << PR0))
	{
		EXTI -> PR &= ~(0 << PR0);
		if(GPIO_Read(BTN_Port, BTN_Pin))
		{
			GPIO_Write(LED4_Port, LED4_Pin, HIGH);
			UART_Writes(USART2, "LED 3: BAT\n", 11);
		}
		else
		{
			GPIO_Write(LED4_Port, LED4_Pin, LOW);
			UART_Writes(USART2, "LED 3: TAT\n", 11);
		}
	}
}

void TIM7_IRQHandler(void)
{
	TIM7 -> SR &= (0 << UIF);
	TIM7 -> CNT = 64535;
	GPIO_Toggle(LED5_Port, LED5_Pin);
}

void USART2_IRQHandler(void)
{
	if(USART2 -> SR & (1 << RXNE))
	{
		USART2_RX_Interrupt();
	}
}

char rx_array[100];
uint8_t rx_index = 0;
void USART2_RX_Interrupt(void)
{
	char chr = UART_ReadChar(USART2);
	if(chr == '{')
	{
		memset(rx_array, 0, 100);
		rx_index = 0;
		rx_array[rx_index] = chr;
		rx_index++;
	}
	else if(chr == '}')
	{
		rx_array[rx_index] = chr;
		rx_index = 0;
	}
	else
	{
		rx_array[rx_index] = chr;
		rx_index++;
	}
	if(FindString(rx_array, "BAT") != 0)
	{
		GPIO_Write(LED6_Port, LED6_Pin, HIGH);
	}
	else if(FindString(rx_array, "TAT") != 0)
	{
		GPIO_Write(LED6_Port, LED6_Pin, LOW);
	}
}

void Hardware_Config(void)
{
	SysClock_Config();
	SysTick_Config(100000);
	GPIO_Config();
	Interrupt_Config();
	TIM6_Config();
	TIM7_Config();
	UART2_Config();
	SPI1_Config();
	SPI3_Config();
	ADC1_Config();
}

/*
 * I2C1_Config();
 *
 * RTC_SET:
 *  DS3231_GetTime(&time);
	if(time.year == 0)
	{
		time.sec = 0;
		time.min = 33;
		time.hour = 15;
		time.AM_PM_24H = 0;
		time.date = 16;
		time.day = 6;
		time.month = 7;
		time.year = 21;
		DS3231_SetTime(&time);
	}
	DS3231_GetTime(&time);

	RTC_Time time;
*/
/*
 * Test SPI: SPI1: Master - SPI3: Slaver
 *
 *
	uint8_t data[5] = {1, 2, 3, 4, 5};
	uint8_t datarv[5];
		SPI_CS_Enable();
		SPI_TransmitReceives(SPI1, SPI3, data, datarv, 4);
		SPI_CS_Disable();
		data[0]++;
		data[2]++;
 */

uint16_t adc_value[2];
uint8_t data[5] = {1, 2, 3, 4, 5};
uint8_t datarv[5];

int main(void)
{
	Hardware_Config();
	TIM6_Delay_ms(200);
	for(;;)
	{
		SPI_CS_Enable();
		SPI_TransmitReceives(SPI1, SPI3, data, datarv, 4);
		SPI_CS_Disable();
		data[0]++;
		data[2]++;
		GPIO_Toggle(LED3_Port, LED3_Pin);
		adc_value[0] = ADC1_GetValue(8);
		adc_value[1] = ADC1_GetValue(9);
		TIM6_Delay_ms(500);
	}
}


/*
	 * Instruction Cache: Enable
	 * Prefetch Buffer	: Enable
	 * Data Cache		: Enable
	 * Flash Latency	: 3 wait state
	 * Power Regulator Voltage Scale: Scale 1
	 * HSE clock: 	8Mhz
	 * Main PLL : Enable
	 * 	+ PLL_M	: 8
	 * 	+ PLL_N	: 200
	 * 	+ PLL_P	: 2
	 * 	=> System Clock = HSE : 8 * 200 : 2 = 100Mhz
	 * AHB Prescale		: DIV1	: System Clock : 1 = 100Mhz
	 * APB1 Prescale	: DIV4	: APB1 Prescale clock: AHB : 4 = 25Mhz
	 * APB2 Prescale	: DIV2	: APB2 Prescale clock: AHB : 2 = 50Mhz
 */


Section void SysClock_Config(void)
{

	FLASH -> ACR |= FLASH_ACR_DCEN | FLASH_ACR_ICEN | FLASH_ACR_PRFTEN | FLASH_ACR_LATENCY_3WS;

	PWR -> CR |= (1 << 14);

	RCC -> CR |= RCC_CR_HSEON | RCC_CR_PLLON;
	while (!(RCC -> CR & RCC_CR_HSERDY));
	while(!(RCC -> CR & RCC_CR_PLLRDY));

	RCC -> PLLCFGR = (PLL_M << 0) | (PLL_N << 6) | (PLL_P << 16) | (RCC_PLLCFGR_PLLSRC_HSE);

	RCC -> CFGR |= RCC_CFGR_HPRE_DIV1 | RCC_CFGR_PPRE1_DIV4 | RCC_CFGR_PPRE2_DIV2 | RCC_CFGR_SW_PLL;
	while(!(RCC -> CFGR & RCC_CFGR_SWS));

}
void GPIO_Config(void)
{
	// Set clock GPIO
	RCC -> AHB1ENR |= (1 << GPIOD_EN);
	// GPIO config
	GPIOD -> MODER |= (OUTPUT << LED3_Pin * 2) | (OUTPUT << LED4_Pin * 2) | (OUTPUT << LED5_Pin * 2) | (OUTPUT << LED6_Pin * 2);
	GPIOD -> OTYPER = (OUTPUT_PP << LED3_Pin) | (OUTPUT_PP << LED4_Pin) | (OUTPUT_PP << LED5_Pin) | (OUTPUT_PP << LED6_Pin);
	GPIOD -> OSPEEDR = (H_SPEED << LED3_Pin * 2) | (H_SPEED << LED4_Pin * 2) | (H_SPEED << LED5_Pin * 2) | (H_SPEED << LED6_Pin * 2);
	GPIOD -> PUPDR = (PUP_N_PP << LED3_Pin) | (PUP_N_PP << LED4_Pin) | (PUP_N_PP << LED5_Pin) | (PUP_N_PP << LED6_Pin);

	RCC -> AHB1ENR |= (1 << GPIOA_EN);
	GPIOA -> MODER |= (INPUT << BTN_Pin);
	GPIOA -> PUPDR |= (PUP_N_PP << BTN_Pin);
}
void Delay_Cycle (uint32_t time)
{
	while (time --);
}

